class TryAngle extends HTMLElement {
    constructor() {
        super();
        
        this.attachShadow({ mode: 'open' });
        
        const template = document.createElement('template');
        template.innerHTML = `
            <style>
                body {
                    font-family: 'Lato', sans-serif;
                }
                .degree-label {
                    font-size: 20px;
                    text-anchor: middle;
                    cursor: pointer;
                    touch-action: none;
                }
                .tic-mark {
                    stroke: black;
                }
                .cursor {
                    fill: red;
                    stroke: red;
                    cursor: pointer;
                    touch-action: none;
                    padding: 50px;
                }
                .center-cross {
                    stroke: black;
                }
                .slider-container {
                    margin-top: 20px;
                }
                .slider-label {
                    display: block;
                    width: 100%;
                    margin-bottom: 5px;
                }
                .slider {
                    width: 200px;
                }
                .input-container {
                    display: flex;
                    align-items: center;
                }
                .input-angle {
                    width:  75px;
                }
                .input-container input[type="number"] {
                    width: 80px;
                    margin-left: 10px;
                }
                #main-container {
                    display: flex;
                    flex-direction: row;
                    flex-wrap: wrap;
                    touch-action: pinch-zoom;
                }
                #controls {
                    flex: 0 1 290px;
                    padding: 10px;
                }
                #data-panel {
                    flex: 0 1 250px;
                    padding: 10px;
                }
                #protractors {
                    flex: 1 1 600px;
                }
            </style>
            <div id="main-container">
                <div id="controls">
                    <!-- Controls will be generated by JavaScript -->
                </div>
                <div id="data-panel">
                    <!-- Data panel will be generated by JavaScript -->
                </div>
                <svg id="protractors" width="100%" height="100%" viewBox="0 0 800 800" preserveAspectRatio="xMidYMid meet">
                    <!-- Protractors will be generated by JavaScript -->
                </svg>
            </div>
        `;
        this.shadowRoot.appendChild(template.content.cloneNode(true));

        this.svgNS = "http://www.w3.org/2000/svg";
        this.protractorsContainer = this.shadowRoot.getElementById('protractors');
        this.controlsContainer = this.shadowRoot.getElementById('controls');
        this.dataPanelContainer = this.shadowRoot.getElementById('data-panel');

        this.BASE_RADIUS = 400 * 0.95; // Default base radius
        this.TAU = 2 * Math.PI;

        this.protractors = [];
        this.draggingProtractor = null;
        this.draggingCursor = null;

        this.regimes = {
            "html5": { name: "html5", unit: "degrees", direction: 1, ratio: 1, offset: 0, minor: 1, major: 10, labelFunction: value => `${this.toFixedWithoutZeros(value, 3)}째` },
            "trig-degrees": { name: "trig-degrees", unit: "degrees", direction: -1, ratio: 1, offset: 0, minor: 1, major: 10, labelFunction: value => `${this.toFixedWithoutZeros(value, 3)}째` },
            "trig-radians": { name: "trig-radians", unit: "radians", direction: -1, ratio: 360 / this.TAU, offset: 0, minor: this.TAU / 64, major: this.TAU / 8, labelFunction: value => `${this.toFixedWithoutZeros(value, 3)}r` },
            "12-hour-clock": { name: "12-hour-clock", unit: "hours", direction: 1, ratio: 30, offset: -90, minor: 0.5, major: 1, labelFunction: value => `${(value % 12 === 0 ? 12 : (value % 12))}` },
            "24-hour-clock": { name: "24-hour-clock", unit: "hours", direction: 1, ratio: 15, offset: -90, minor: 0.5, major: 1, labelFunction: value => `${(value % 24 === 0 ? 24 : (value % 24))}` },
            "nav-marine": { name: "nav-marine", unit: "degrees", direction: 1, ratio: 1, offset: -90, minor: 1, major: 10, labelFunction: value => `${this.toFixedWithoutZeros(value, 3)}째` },
            "declination": {
                name: "declination", unit: "dms", direction: 1, ratio: 1, offset: -90, minor: 5, major: 2, labelFunction: value => {
                    const isNegative = value < 0;
                    const absValue = Math.abs(value);
                    const degrees = Math.floor(absValue);
                    const minutes = Math.floor((absValue - degrees) * 60);
                    const seconds = Math.floor(((absValue - degrees) * 60 - minutes) * 60);
                    const sign = isNegative ? '-' : '';
                    return `${sign}${degrees}째 ${minutes}' ${seconds}"`
                }
            },
            "right ascention": {
                name: "right ascention", unit: "hms", direction: 1, ratio: 15, offset: -90, minor: 0.5, major: 1, labelFunction: value => {
                    const isNegative = value < 0;
                    const absValue = Math.abs(value);
                    const hours = Math.floor(absValue);
                    const minutes = Math.floor((absValue - hours) * 60);
                    const seconds = Math.floor(((absValue - hours) * 60 - minutes) * 60);
                    const sign = isNegative ? '-' : '';
                    return `${sign}${hours}h ${minutes}' ${seconds}"`
                }
            }
        };

        this.protractorSize = 800; // Default protractor size

        this.initialRegime1 = 'trig-degrees';
        this.initialRegime2 = 'html5';
        this.defaultRotation1 = 0;
        this.defaultRotation2 = 45;
        this.defaultCursor1 = 0;
        this.defaultCursor2 = 0;

        this.controlsVisible = true;
        this.pageNormalizedDataVisible = true;

        this.setupComponent();
    }

    setupComponent() {
        const protractorSizeAttr = this.getAttribute('protractor-size');
        const regime1Attr = this.getAttribute('initial-regime1');
        const regime2Attr = this.getAttribute('initial-regime2');
        const rotation1Attr = this.getAttribute('default-rotation1');
        const rotation2Attr = this.getAttribute('default-rotation2');
        const cursor1Attr = this.getAttribute('default-cursor1');
        const cursor2Attr = this.getAttribute('default-cursor2');
        const controlsVisibleAttr = this.getAttribute('controls-visible');
        const pageNormalizedDataVisibleAttr = this.getAttribute('page-normalized-data-visible');

        if (protractorSizeAttr) {
            this.protractorSize = parseInt(protractorSizeAttr, 10);
            this.BASE_RADIUS = this.protractorSize / 2 * 0.95;
        }
        if (regime1Attr) {
            this.initialRegime1 = regime1Attr;
        }
        if (regime2Attr) {
            this.initialRegime2 = regime2Attr;
        }
        if (rotation1Attr) {
            this.defaultRotation1 = parseFloat(rotation1Attr);
        }
        if (rotation2Attr) {
            this.defaultRotation2 = parseFloat(rotation2Attr);
        }
        if (cursor1Attr) {
            this.defaultCursor1 = parseFloat(cursor1Attr);
        }
        if (cursor2Attr) {
            this.defaultCursor2 = parseFloat(cursor2Attr);
        }
        if (controlsVisibleAttr === 'false') {
            this.controlsVisible = false;
            this.controlsContainer.style.display = 'none';
        }
        if (pageNormalizedDataVisibleAttr === 'false') {
            this.pageNormalizedDataVisible = false;
        }

        this.initializeProtractors();
    }

    toFixedWithoutZeros(num, precision) {
        return `${Number.parseFloat(num.toFixed(precision))}`;
    }

    regimeToCanvas(angle_regime, regime) {
        return angle_regime * regime.direction * regime.ratio;
    }

    convertCursorValue(oldValue, oldRegime, newRegime) {
        const oldValueInDegrees = oldValue * oldRegime.ratio;
        return oldValueInDegrees / newRegime.ratio;
    }

    convertRotationValue(oldRotation, oldRegime, newRegime) {
        const oldRotationInDegrees = oldRotation * oldRegime.ratio;
        return oldRotationInDegrees / newRegime.ratio;
    }

    createProtractor(id, cx, cy, scale, rotation, regimeName) {
        const protractorGroup = this.createProtractorGroup(cx, cy, scale, rotation, regimeName);

        this.protractors.push({
            id: id,
            cx: cx,
            cy: cy,
            scale: scale,
            rotation: rotation,
            cursorPosition: 0, // Default cursor position
            regime: this.regimes[regimeName],
            group: protractorGroup,
            cursor: null, // Placeholder for cursor
            element: this.createControls(id, rotation, regimeName, scale)
        });

        // Append the protractor group to the container
        this.protractorsContainer.appendChild(protractorGroup);

        // Cursor (drawn last)
        const cursor = document.createElementNS(this.svgNS, 'circle');
        cursor.setAttribute('class', 'cursor');
        cursor.setAttribute('r', 20); // Larger circle for handle
        cursor.setAttribute('cx', 0); // Red dot center
        cursor.setAttribute('cy', 0); // Red dot center
        cursor.style.fill = "rgba(255,0,0,0.3)"; // Transparent red for handle
        const cursorDot = document.createElementNS(this.svgNS, 'circle');
        cursorDot.setAttribute('r', 10); // Red dot radius
        cursorDot.style.fill = "red";
        cursor.appendChild(cursorDot);
        this.positionCursor(cursor, 0, this.regimes[regimeName], scale); // Position cursor correctly

        this.protractors[this.protractors.length - 1].cursor = cursor;
        protractorGroup.appendChild(cursor);

        // Add event listeners for dragging
        this.addDragListeners(protractorGroup, cursor, id);

        // Update the data panel initially
        this.updateDataPanel();
    }

    createProtractorGroup(cx, cy, scale, rotation, regimeName) {
        const regime = this.regimes[regimeName];
        const protractorGroup = document.createElementNS(this.svgNS, 'g');
        protractorGroup.setAttribute('transform', `translate(${cx}, ${cy}) scale(${scale}) rotate(${this.regimeToCanvas(rotation, regime) + regime.offset})`);

        // Circle
        const circle = document.createElementNS(this.svgNS, 'circle');
        circle.setAttribute('cx', 0);
        circle.setAttribute('cy', 0);
        circle.setAttribute('r', this.BASE_RADIUS);
        circle.setAttribute('stroke', 'black');
        circle.setAttribute('fill', 'none');
        protractorGroup.appendChild(circle);

        // Center cross
        const centerCross1 = document.createElementNS(this.svgNS, 'line');
        centerCross1.setAttribute('x1', -5);
        centerCross1.setAttribute('y1', 0);
        centerCross1.setAttribute('x2', 5);
        centerCross1.setAttribute('y2', 0);
        centerCross1.setAttribute('class', 'center-cross');
        protractorGroup.appendChild(centerCross1);

        const centerCross2 = document.createElementNS(this.svgNS, 'line');
        centerCross2.setAttribute('x1', 0);
        centerCross2.setAttribute('y1', -5);
        centerCross2.setAttribute('x2', 0);
        centerCross2.setAttribute('y2', 5);
        centerCross2.setAttribute('class', 'center-cross');
        protractorGroup.appendChild(centerCross2);

        // Tic marks and labels
        const minorTickLength = 10;
        const majorTickLength = 20;

        const totalTicks = 360 / regime.minor / regime.ratio; // Total ticks for the regime

        for (let i = 0; i < totalTicks; i++) {
            const value_regime = i * regime.minor;
            const angle_canvas_degrees = this.regimeToCanvas(value_regime, regime);
            const angle_canvas_radians = angle_canvas_degrees * (Math.PI / 180); // Convert to radians for trig functions

            const x1 = this.BASE_RADIUS * Math.cos(angle_canvas_radians);
            const y1 = this.BASE_RADIUS * Math.sin(angle_canvas_radians);
            const length = (value_regime % regime.major === 0) ? majorTickLength : minorTickLength;
            const x2 = (this.BASE_RADIUS - length) * Math.cos(angle_canvas_radians);
            const y2 = (this.BASE_RADIUS - length) * Math.sin(angle_canvas_radians);

            const ticMark = document.createElementNS(this.svgNS, 'line');
            ticMark.setAttribute('x1', x1);
            ticMark.setAttribute('y1', y1);
            ticMark.setAttribute('x2', x2);
            ticMark.setAttribute('y2', y2);
            ticMark.setAttribute('class', 'tic-mark');
            protractorGroup.appendChild(ticMark);

            if (value_regime % regime.major === 0) {
                const labelX = (this.BASE_RADIUS - majorTickLength - 10) * Math.cos(angle_canvas_radians);
                const labelY = (this.BASE_RADIUS - majorTickLength - 10) * Math.sin(angle_canvas_radians);
                const label = document.createElementNS(this.svgNS, 'text');
                label.setAttribute('x', labelX);
                label.setAttribute('y', labelY);
                label.setAttribute('class', 'degree-label');
                label.setAttribute('transform', `rotate(${angle_canvas_degrees}, ${labelX}, ${labelY})`);
                label.textContent = regime.labelFunction(value_regime);
                protractorGroup.appendChild(label);
            }
        }

        return protractorGroup;
    }

    positionCursor(cursor, cursorPosition, regime, scale) {
        const angle_canvas = this.regimeToCanvas(cursorPosition, regime);
        const angle_canvas_radians = angle_canvas * (Math.PI / 180); // Convert to radians for trig functions
        const x = this.BASE_RADIUS * Math.cos(angle_canvas_radians);
        const y = this.BASE_RADIUS * Math.sin(angle_canvas_radians);
        cursor.setAttribute('transform', `translate(${x}, ${y}) scale(${scale})`);
    }
    addDragListeners(protractorGroup, cursor, id) {
        let isDraggingProtractor = false;
        let isDraggingCursor = false;
        let startAngleProtractor = 0;
        let startAngleCursor = 0;
    
        const onPointerDown = (event) => {
            event.preventDefault();
            const target = event.target;
    
            if (target.closest('.cursor')) {
                isDraggingCursor = true;
                startAngleCursor = this.getPointerAngle(event, protractorGroup);
                cursor.setPointerCapture(event.pointerId);  // Capture pointer events for the cursor
            } else {
                isDraggingProtractor = true;
                startAngleProtractor = this.getPointerAngle(event, protractorGroup);
                protractorGroup.setPointerCapture(event.pointerId);  // Capture pointer events for the protractor group
            }
    
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
        };
    
        const onPointerMove = (event) => {
            const protractor = this.protractors.find(p => p.id === id);
            if (!protractor) return;
    
            if (isDraggingProtractor) {
                const angle = this.getPointerAngle(event, protractorGroup);
                const delta = (angle - startAngleProtractor) * this.regimes[protractor.regime.name].direction;
                startAngleProtractor = angle;
    
                protractor.rotation += delta / protractor.regime.ratio;
                this.updateProtractorRotation(id, protractor.rotation);
                this.updateControls(id, 'rotation', protractor.rotation);
                this.updateDataPanel();
            } else if (isDraggingCursor) {
                const angle = this.getPointerAngle(event, protractorGroup);
                const delta = (angle - startAngleCursor) * this.regimes[protractor.regime.name].direction;
                startAngleCursor = angle;
    
                protractor.cursorPosition += delta / protractor.regime.ratio;
                if (protractor.cursorPosition < 0) {
                    protractor.cursorPosition += 360 / protractor.regime.ratio;
                } else if (protractor.cursorPosition >= 360 / protractor.regime.ratio) {
                    protractor.cursorPosition -= 360 / protractor.regime.ratio;
                }
                this.updateProtractorCursor(id, protractor.cursorPosition);
                this.updateControls(id, 'cursor', protractor.cursorPosition);
                this.updateDataPanel();
            }
        };
    
        const onPointerUp = (event) => {
            if (isDraggingCursor) {
                cursor.releasePointerCapture(event.pointerId);  // Release pointer capture for the cursor
            }
            if (isDraggingProtractor) {
                protractorGroup.releasePointerCapture(event.pointerId);  // Release pointer capture for the protractor group
            }
    
            isDraggingProtractor = false;
            isDraggingCursor = false;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
        };
    
        protractorGroup.addEventListener('pointerdown', onPointerDown);
        cursor.addEventListener('pointerdown', onPointerDown);
    }
    

    getPointerAngle(event, element) {
        const rect = this.protractorsContainer.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const x = event.clientX - cx;
        const y = event.clientY - cy;
        return Math.atan2(y, x) * (180 / Math.PI);
    }

    createControls(id, initialRotation, regimeName, scale) {
        const regime = this.regimes[regimeName];
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'slider-container';
        controlsContainer.setAttribute('id', `controls-${id}`);

        // Regime Selector
        const regimeLabel = document.createElement('label');
        regimeLabel.textContent = `Protractor ${id} Regime: `;
        controlsContainer.appendChild(regimeLabel);

        const regimeSelect = document.createElement('select');
        regimeSelect.onchange = () => {
            const newRegimeName = regimeSelect.value;
            this.updateProtractorRegime(id, newRegimeName);
        };
        for (let key in this.regimes) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = this.regimes[key].name;
            if (key === regimeName) {
                option.selected = true;
            }
            regimeSelect.appendChild(option);
        }
        controlsContainer.appendChild(regimeSelect);

        // Rotation Slider
        const rotationContainer = document.createElement('div');
        rotationContainer.setAttribute('id', `rotation-controls-${id}`);

        const sliderLabel = document.createElement('span');
        sliderLabel.className = 'slider-label';
        sliderLabel.textContent = `Rotation (${regime.unit}): `;
        rotationContainer.appendChild(sliderLabel);

        const slider = document.createElement('input');
        slider.className = 'slider';
        slider.type = 'range';
        slider.min = -3 * 360 / regime.ratio;  // Allow for 3 full rotations in either direction
        slider.max = 3 * 360 / regime.ratio;
        slider.value = initialRotation;
        slider.oninput = () => {
            const rotation = parseFloat(slider.value);
            input.value = rotation.toFixed(3);
            this.updateProtractorRotation(id, rotation);
            this.updateDataPanel(); // Update data panel on rotation change
        };
        slider.onchange = () => {
            input.value = parseFloat(slider.value).toFixed(3);
        };
        rotationContainer.appendChild(slider);

        // Rotation Input
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'input-angle';
        input.value = parseFloat(initialRotation).toFixed(3);
        input.step = 0.01;
        input.oninput = () => {
            const rotation = parseFloat(input.value);
            slider.value = rotation;
            this.updateProtractorRotation(id, rotation);
            this.updateDataPanel(); // Update data panel on rotation change
        };
        rotationContainer.appendChild(input);

        controlsContainer.appendChild(rotationContainer);

        // Cursor Slider
        const cursorContainer = document.createElement('div');
        cursorContainer.setAttribute('id', `cursor-controls-${id}`);

        const cursorLabel = document.createElement('span');
        cursorLabel.className = 'slider-label';
        cursorLabel.textContent = `Cursor (${regime.unit}): `;
        cursorContainer.appendChild(cursorLabel);

        const cursorSlider = document.createElement('input');
        cursorSlider.type = 'range';
        cursorSlider.className = 'slider';
        cursorSlider.min = 0;
        cursorSlider.max = 360 / regime.ratio;  // Full rotation in the unit of the regime
        cursorSlider.step = 0.01;
        cursorSlider.value = 0; // Default to 0
        cursorSlider.oninput = () => {
            const cursorPosition = parseFloat(cursorSlider.value);
            cursorInput.value = cursorPosition.toFixed(3);
            this.updateProtractorCursor(id, cursorPosition);
            this.updateDataPanel(); // Update data panel on cursor position change
        };
        cursorSlider.onchange = () => {
            cursorInput.value = parseFloat(cursorSlider.value).toFixed(3);
        };
        cursorContainer.appendChild(cursorSlider);

        // Cursor Input
        const cursorInput = document.createElement('input');
        cursorInput.type = 'number';
        cursorInput.className = 'input-angle';
        cursorInput.value = 0; // Default to 0
        cursorInput.step = 0.01;
        cursorInput.oninput = () => {
            const cursorPosition = parseFloat(cursorInput.value);
            cursorSlider.value = cursorPosition;
            this.updateProtractorCursor(id, cursorPosition);
            this.updateDataPanel(); // Update data panel on cursor position change
        };
        cursorContainer.appendChild(cursorInput);

        controlsContainer.appendChild(cursorContainer);

        controlsContainer.appendChild(document.createElement('br'));

        // Append to main controls container
        this.shadowRoot.getElementById('controls').appendChild(controlsContainer);

        return controlsContainer;
    }

    updateControls(id, type, value) {
        const controlsContainer = this.shadowRoot.getElementById(`controls-${id}`);
        if (controlsContainer) {
            const controlId = type === 'rotation' ? `rotation-controls-${id}` : `cursor-controls-${id}`;
            const controlContainer = this.shadowRoot.getElementById(controlId);
            const slider = controlContainer.querySelector(`input[type="range"]`);
            const input = controlContainer.querySelector(`input[type="number"]`);

            if (slider && input) {
                slider.value = value;
                input.value = value.toFixed(3);
            }
        }
    }

    updateProtractorRotation(id, rotation) {
        const protractor = this.protractors.find(p => p.id === id);
        if (protractor) {
            protractor.rotation = rotation;
            const rotationCanvas = this.regimeToCanvas(rotation, protractor.regime) + protractor.regime.offset;
            protractor.group.setAttribute('transform', `translate(${protractor.cx}, ${protractor.cy}) scale(${protractor.scale}) rotate(${rotationCanvas})`);
        }
    }

    updateProtractorCursor(id, cursorPosition) {
        const protractor = this.protractors.find(p => p.id === id);
        if (protractor) {
            protractor.cursorPosition = cursorPosition;
            this.positionCursor(protractor.cursor, cursorPosition, protractor.regime, protractor.scale);
        }
    }

    updateProtractorRegime(id, newRegimeName) {
        // Cache the current settings of the protractors
        const cachedProtractors = this.protractors.map(protractor => ({
            id: protractor.id,
            cx: protractor.cx,
            cy: protractor.cy,
            scale: protractor.scale,
            rotation: protractor.rotation,
            cursorPosition: protractor.cursorPosition,
            regimeName: protractor.regime.name
        }));

        const protractorToUpdate = cachedProtractors.find(p => p.id === id);
        if (protractorToUpdate) {
            protractorToUpdate.regimeName = newRegimeName;

            // Convert cursor position and rotation from old regime to new regime
            const oldRegime = this.protractors.find(p => p.id === id).regime;
            const newRegime = this.regimes[newRegimeName];

            protractorToUpdate.cursorPosition = this.convertCursorValue(protractorToUpdate.cursorPosition, oldRegime, newRegime);
            protractorToUpdate.rotation = this.convertRotationValue(protractorToUpdate.rotation, oldRegime, newRegime);
        }

        // Remove all protractors and controls
        while (this.protractorsContainer.firstChild) {
            this.protractorsContainer.removeChild(this.protractorsContainer.firstChild);
        }
        this.protractors = [];

        // Recreate both protractors with updated regime
        cachedProtractors.forEach(protractor => {
            this.createProtractor(protractor.id, protractor.cx, protractor.cy, protractor.scale, protractor.rotation, protractor.regimeName);
            this.updateProtractorCursor(protractor.id, protractor.cursorPosition); // Update cursor position
        });

        // Redraw all controls
        while (this.controlsContainer.firstChild) {
            this.controlsContainer.removeChild(this.controlsContainer.firstChild);
        }
        this.protractors.forEach(p => {
            this.createControls(p.id, p.rotation, p.regime.name, p.scale);
        });

        // Update data panel on regime change
        this.updateDataPanel();
    }

    calculateAngleDifference(angle1, angle2) {
        let diff = angle1 - angle2;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return diff;
    }

    updateDataPanel() {
        const dataPanel = this.shadowRoot.getElementById('data-panel');
        dataPanel.innerHTML = '';

        if (this.protractors.length < 2) {
            dataPanel.textContent = 'Not enough protractors to calculate relative angles.';
            return;
        }

        const p1 = this.protractors[0];
        const p2 = this.protractors[1];

        // Calculate relative angles (Page normalized relative angles)
        const p1RotationCanvas = this.regimeToCanvas(p1.rotation, p1.regime) + p1.regime.offset;
        const p2RotationCanvas = this.regimeToCanvas(p2.rotation, p2.regime) + p2.regime.offset;

        const p1CursorCanvas = this.regimeToCanvas(p1.cursorPosition, p1.regime);
        const p2CursorCanvas = this.regimeToCanvas(p2.cursorPosition, p2.regime);

        const p1RelativeToP2Canvas = this.calculateAngleDifference(p1RotationCanvas, p2RotationCanvas);
        const p2RelativeToP1Canvas = this.calculateAngleDifference(p2RotationCanvas, p1RotationCanvas);

        const p1RelativeToP2InP1Units = p1.regime.labelFunction(p1RelativeToP2Canvas / p1.regime.ratio);
        const p1RelativeToP2InP2Units = p2.regime.labelFunction(p1RelativeToP2Canvas / p2.regime.ratio);

        const p2RelativeToP1InP2Units = p2.regime.labelFunction(p2RelativeToP1Canvas / p2.regime.ratio);
        const p2RelativeToP1InP1Units = p1.regime.labelFunction(p2RelativeToP1Canvas / p1.regime.ratio);

        const p1CursorRelativeToP2Canvas = this.calculateAngleDifference(p1RotationCanvas + p1CursorCanvas, p2RotationCanvas);
        const p2CursorRelativeToP1Canvas = this.calculateAngleDifference(p2RotationCanvas + p2CursorCanvas, p1RotationCanvas);

        const p1CursorRelativeToP2InP1Units = p1.regime.labelFunction(p1CursorRelativeToP2Canvas / p1.regime.ratio);
        const p1CursorRelativeToP2InP2Units = p2.regime.labelFunction(p1CursorRelativeToP2Canvas / p2.regime.ratio);

        const p2CursorRelativeToP1InP2Units = p2.regime.labelFunction(p2CursorRelativeToP1Canvas / p2.regime.ratio);
        const p2CursorRelativeToP1InP1Units = p1.regime.labelFunction(p2CursorRelativeToP1Canvas / p1.regime.ratio);

        const cursorToCursorCanvasP1toP2 = this.calculateAngleDifference(p1RotationCanvas + p1CursorCanvas, p2RotationCanvas + p2CursorCanvas);
        const cursorToCursorCanvasP2toP1 = this.calculateAngleDifference(p2RotationCanvas + p2CursorCanvas, p1RotationCanvas + p1CursorCanvas);

        const cursorToCursorInP1Units = p1.regime.labelFunction(cursorToCursorCanvasP1toP2 / p1.regime.ratio);
        const cursorToCursorInP2Units = p2.regime.labelFunction(cursorToCursorCanvasP1toP2 / p2.regime.ratio);
        const cursorToCursorInP1UnitsOpposite = p1.regime.labelFunction(cursorToCursorCanvasP2toP1 / p1.regime.ratio);
        const cursorToCursorInP2UnitsOpposite = p2.regime.labelFunction(cursorToCursorCanvasP2toP1 / p2.regime.ratio);

        // Display Page normalized relative angles
        dataPanel.innerHTML = `
            <p>Page Normalized Relative Angles:</p>
            <ul>
                <li>P1=>P2: ${p1RelativeToP2InP1Units}, ${p1RelativeToP2InP2Units}</li>
                <li>P2=>P1: ${p2RelativeToP1InP2Units}, ${p2RelativeToP1InP1Units}</li>
                <li>C1=>P2: ${p1CursorRelativeToP2InP1Units}, ${p1CursorRelativeToP2InP2Units}</li>
                <li>C2=>P1: ${p2CursorRelativeToP1InP2Units}, ${p2CursorRelativeToP1InP1Units}</li>
                <li>C1=>C2: ${cursorToCursorInP1Units}, ${cursorToCursorInP2Units}</li>
                <li>C2=>C1: ${cursorToCursorInP2UnitsOpposite}, ${cursorToCursorInP1UnitsOpposite}</li>
            </ul>
        `;

        // Calculate Direct relative angles (Direct relative angles)
        const p1RotationDirect = p1.rotation * p1.regime.ratio;
        const p2RotationDirect = p2.rotation * p2.regime.ratio;

        const p1CursorDirect = p1.cursorPosition * p1.regime.ratio;
        const p2CursorDirect = p2.cursorPosition * p2.regime.ratio;

        const p1RelativeToP2Direct = p1RotationDirect - p2RotationDirect;
        const p2RelativeToP1Direct = p2RotationDirect - p1RotationDirect;

        const p1RelativeToP2DirectInP1Units = p1.regime.labelFunction(p1RelativeToP2Direct / p1.regime.ratio);
        const p1RelativeToP2DirectInP2Units = p2.regime.labelFunction(p1RelativeToP2Direct / p2.regime.ratio);

        const p2RelativeToP1DirectInP2Units = p2.regime.labelFunction(p2RelativeToP1Direct / p2.regime.ratio);
        const p2RelativeToP1DirectInP1Units = p1.regime.labelFunction(p2RelativeToP1Direct / p1.regime.ratio);

        const p1CursorRelativeToP2Direct = (p1RotationDirect + p1CursorDirect) - p2RotationDirect;
        const p2CursorRelativeToP1Direct = (p2RotationDirect + p2CursorDirect) - p1RotationDirect;

        const p1CursorRelativeToP2DirectInP1Units = p1.regime.labelFunction(p1CursorRelativeToP2Direct / p1.regime.ratio);
        const p1CursorRelativeToP2DirectInP2Units = p2.regime.labelFunction(p1CursorRelativeToP2Direct / p2.regime.ratio);

        const p2CursorRelativeToP1DirectInP2Units = p2.regime.labelFunction(p2CursorRelativeToP1Direct / p2.regime.ratio);
        const p2CursorRelativeToP1DirectInP1Units = p1.regime.labelFunction(p2CursorRelativeToP1Direct / p1.regime.ratio);

        const cursorToCursorDirectP1toP2 = (p1RotationDirect + p1CursorDirect) - (p2RotationDirect + p2CursorDirect);
        const cursorToCursorDirectP2toP1 = (p2RotationDirect + p2CursorDirect) - (p1RotationDirect + p1CursorDirect);

        const cursorToCursorDirectInP1Units = p1.regime.labelFunction(cursorToCursorDirectP1toP2 / p1.regime.ratio);
        const cursorToCursorDirectInP2Units = p2.regime.labelFunction(cursorToCursorDirectP1toP2 / p2.regime.ratio);
        const cursorToCursorDirectInP1UnitsOpposite = p1.regime.labelFunction(cursorToCursorDirectP2toP1 / p1.regime.ratio);
        const cursorToCursorDirectInP2UnitsOpposite = p2.regime.labelFunction(cursorToCursorDirectP2toP1 / p2.regime.ratio);

        // Display Direct relative angles
        dataPanel.innerHTML += `
            <p>Direct Relative Angles:</p>
            <ul>
                <li>P1=>P2: ${p1RelativeToP2DirectInP1Units}, ${p1RelativeToP2DirectInP2Units}</li>
                <li>P2=>P1: ${p2RelativeToP1DirectInP2Units}, ${p2RelativeToP1DirectInP1Units}</li>
                <li>C1=>P2: ${p1CursorRelativeToP2DirectInP1Units}, ${p1CursorRelativeToP2DirectInP2Units}</li>
                <li>C2=>P1: ${p2CursorRelativeToP1DirectInP2Units}, ${p2CursorRelativeToP1DirectInP1Units}</li>
                <li>C1=>C2: ${cursorToCursorDirectInP1Units}, ${cursorToCursorDirectInP2Units}</li>
                <li>C2=>C1: ${cursorToCursorDirectInP2UnitsOpposite}, ${cursorToCursorDirectInP1UnitsOpposite}</li>
            </ul>
        `;
    }

    initializeProtractors() {
        this.createProtractor(1, 400, 400, 1, this.defaultRotation1, this.initialRegime1);
        this.createProtractor(2, 400, 400, 0.75, this.defaultRotation2, this.initialRegime2);  // Example of overlapping protractors with different scales and regimes
    }
}

customElements.define('try-angle', TryAngle);
