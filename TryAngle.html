<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Improved Full Unit Circle Protractor</title>
    <style>
        .degree-label {
            font-size: 24px; /* Tripled font size */
            text-anchor: middle;
        }
        .tic-mark {
            stroke: black;
        }
        .cursor {
            fill: red;
            stroke: red;
            r: 5;
            cx: 0;
            cy: 0;
        }
        .center-cross {
            stroke: black;
        }
        .slider-container {
            margin-top: 20px;
        }
        .slider-label {
            margin-right: 10px;
        }
        .slider-value {
            margin-left: 10px;
        }
        #main-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }
        #controls {
            flex: 1 1 200px;
            padding: 10px;
        }
        #protractors {
            flex: 3 1 600px;
        }
        #data-panel {
            flex: 1 1 100%;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="controls">
            <!-- Controls will be generated by JavaScript -->
        </div>
        <svg id="protractors" width="800" height="800" viewBox="0 0 800 800">
            <!-- Protractors will be generated by JavaScript -->
        </svg>
    </div>
    <div id="data-panel">
        <!-- Data panel will be generated by JavaScript -->
    </div>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const protractorsContainer = document.getElementById('protractors');
        const controlsContainer = document.getElementById('controls');
        const dataPanelContainer = document.getElementById('data-panel');

        const BASE_RADIUS = 380;
        const TAU = 2 * Math.PI;

        let protractors = [];

        const regimes = {
            "html5": { name: "html5", unit: "degrees", direction: 1, ratio: 1, offset: 0, minor: 1, major: 10, labelFunction: value => `${value}째` },
            "trig-degrees": { name: "trig-degrees", unit: "degrees", direction: -1, ratio: 1, offset: 0, minor: 1, major: 10, labelFunction: value => `${value}째` },
            "trig-radians": { name: "trig-radians", unit: "radians", direction: -1, ratio: 360 / TAU, offset: 0, minor: TAU / 64, major: TAU / 8, labelFunction: value => `${(value).toFixed(2)}r` },
            "12-hour-clock": { name: "12-hour-clock", unit: "hours", direction: 1, ratio: 30, offset: -90, minor: 0.5, major: 1, labelFunction: value => `${value % 12 === 0 ? 12 : value % 12}` },
            "24-hour-clock": { name: "24-hour-clock", unit: "hours", direction: 1, ratio: 15, offset: -90, minor: 0.5, major: 1, labelFunction: value => `${value % 24 === 0 ? 24 : value % 24}` },
            "nav-marine": { name: "nav-marine", unit: "degrees", direction: 1, ratio: 1, offset: -90, minor: 1, major: 10, labelFunction: value => `${value}째` },
            "astronomy": {
                name: "astronomy", unit: "dms", direction: 1, ratio: 1, offset: -90, minor: 5, major: 2, labelFunction: value => {
                    const isNegative = value < 0;
                    const absValue = Math.abs(value);
                    const degrees = Math.floor(absValue);
                    const minutes = Math.floor((absValue - degrees) * 60);
                    const seconds = Math.floor(((absValue - degrees) * 60 - minutes) * 60);
                    const sign = isNegative ? '-' : '';
                    return `${sign}${degrees}째 ${minutes}' ${seconds}"`
                }
            }
        };

        function regimeToCanvas(angle_regime, regime) {
            return angle_regime * regime.direction * regime.ratio;
        }

        function convertCursorValue(oldValue, oldRegime, newRegime) {
            const oldValueInDegrees = oldValue * oldRegime.ratio;
            return oldValueInDegrees / newRegime.ratio;
        }

        function convertRotationValue(oldRotation, oldRegime, newRegime) {
            const oldRotationInDegrees = oldRotation * oldRegime.ratio;
            return oldRotationInDegrees / newRegime.ratio;
        }

        function createProtractor(id, cx, cy, scale, rotation, regimeName) {
            const protractorGroup = createProtractorGroup(cx, cy, scale, rotation, regimeName);

            protractors.push({
                id: id,
                cx: cx,
                cy: cy,
                scale: scale,
                rotation: rotation,
                cursorPosition: 0, // Default cursor position
                regime: regimes[regimeName],
                group: protractorGroup,
                cursor: null, // Placeholder for cursor
                element: createControls(id, rotation, regimeName, scale)
            });

            // Append the protractor group to the container
            protractorsContainer.appendChild(protractorGroup);

            // Cursor (drawn last)
            const cursor = document.createElementNS(svgNS, 'circle');
            cursor.setAttribute('class', 'cursor');
            positionCursor(cursor, 0, regimes[regimeName], scale); // Position cursor correctly
            protractors[protractors.length - 1].cursor = cursor;
            protractorGroup.appendChild(cursor);

            // Update the data panel initially
            updateDataPanel();
        }

        function createProtractorGroup(cx, cy, scale, rotation, regimeName) {
            const regime = regimes[regimeName];
            const protractorGroup = document.createElementNS(svgNS, 'g');
            protractorGroup.setAttribute('transform', `translate(${cx}, ${cy}) scale(${scale}) rotate(${regimeToCanvas(rotation, regime) + regime.offset})`);

            // Circle
            const circle = document.createElementNS(svgNS, 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', BASE_RADIUS);
            circle.setAttribute('stroke', 'black');
            circle.setAttribute('fill', 'none');
            protractorGroup.appendChild(circle);

            // Center cross
            const centerCross1 = document.createElementNS(svgNS, 'line');
            centerCross1.setAttribute('x1', -5);
            centerCross1.setAttribute('y1', 0);
            centerCross1.setAttribute('x2', 5);
            centerCross1.setAttribute('y2', 0);
            centerCross1.setAttribute('class', 'center-cross');
            protractorGroup.appendChild(centerCross1);

            const centerCross2 = document.createElementNS(svgNS, 'line');
            centerCross2.setAttribute('x1', 0);
            centerCross2.setAttribute('y1', -5);
            centerCross2.setAttribute('x2', 0);
            centerCross2.setAttribute('y2', 5);
            centerCross2.setAttribute('class', 'center-cross');
            protractorGroup.appendChild(centerCross2);

            // Tic marks and labels
            const minorTickLength = 10;
            const majorTickLength = 20;

            const totalTicks = 360 / regime.minor / regime.ratio; // Total ticks for the regime

            for (let i = 0; i < totalTicks; i++) {
                const value_regime = i * regime.minor;
                const angle_canvas_degrees = regimeToCanvas(value_regime, regime);
                const angle_canvas_radians = angle_canvas_degrees * (Math.PI / 180); // Convert to radians for trig functions

                const x1 = BASE_RADIUS * Math.cos(angle_canvas_radians);
                const y1 = BASE_RADIUS * Math.sin(angle_canvas_radians);
                const length = (value_regime % regime.major === 0) ? majorTickLength : minorTickLength;
                const x2 = (BASE_RADIUS - length) * Math.cos(angle_canvas_radians);
                const y2 = (BASE_RADIUS - length) * Math.sin(angle_canvas_radians);

                const ticMark = document.createElementNS(svgNS, 'line');
                ticMark.setAttribute('x1', x1);
                ticMark.setAttribute('y1', y1);
                ticMark.setAttribute('x2', x2);
                ticMark.setAttribute('y2', y2);
                ticMark.setAttribute('class', 'tic-mark');
                protractorGroup.appendChild(ticMark);

                if (value_regime % regime.major === 0) {
                    const labelX = (BASE_RADIUS - majorTickLength - 10) * Math.cos(angle_canvas_radians);
                    const labelY = (BASE_RADIUS - majorTickLength - 10) * Math.sin(angle_canvas_radians);
                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', labelX);
                    label.setAttribute('y', labelY);
                    label.setAttribute('class', 'degree-label');
                    label.setAttribute('transform', `rotate(${angle_canvas_degrees}, ${labelX}, ${labelY})`);
                    label.setAttribute('style', 'font-size: 24px'); // Tripled font size
                    label.textContent = regime.labelFunction(value_regime);
                    protractorGroup.appendChild(label);
                }
            }

            return protractorGroup;
        }

        function positionCursor(cursor, cursorPosition, regime, scale) {
            const angle_canvas = regimeToCanvas(cursorPosition, regime);
            const angle_canvas_radians = angle_canvas * (Math.PI / 180); // Convert to radians for trig functions
            const x = BASE_RADIUS * Math.cos(angle_canvas_radians);
            const y = BASE_RADIUS * Math.sin(angle_canvas_radians);
            cursor.setAttribute('transform', `translate(${x}, ${y}) scale(${scale})`);
        }

        function createControls(id, initialRotation, regimeName, scale) {
            const regime = regimes[regimeName];
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'slider-container';
            controlsContainer.setAttribute('id', `controls-${id}`);

            // Regime Selector
            const regimeLabel = document.createElement('label');
            regimeLabel.textContent = `Protractor ${id} Regime: `;
            controlsContainer.appendChild(regimeLabel);

            const regimeSelect = document.createElement('select');
            regimeSelect.onchange = function() {
                const newRegimeName = regimeSelect.value;
                updateProtractorRegime(id, newRegimeName);
            };
            for (let key in regimes) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = regimes[key].name;
                if (key === regimeName) {
                    option.selected = true;
                }
                regimeSelect.appendChild(option);
            }
            controlsContainer.appendChild(regimeSelect);

            // Rotation Slider
            const sliderLabel = document.createElement('span');
            sliderLabel.className = 'slider-label';
            sliderLabel.textContent = ` Rotation (${regime.unit}): `;
            controlsContainer.appendChild(sliderLabel);

            const sliderValue = document.createElement('span');
            sliderValue.className = 'slider-value';
            sliderValue.textContent = initialRotation;
            controlsContainer.appendChild(sliderValue);

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = -3 * 360 / regime.ratio;  // Allow for 3 full rotations in either direction
            slider.max = 3 * 360 / regime.ratio;
            slider.value = initialRotation;
            slider.oninput = function() {
                const rotation = parseFloat(slider.value);
                sliderValue.textContent = rotation;
                input.value = rotation;
                updateProtractorRotation(id, rotation);
                updateDataPanel(); // Update data panel on rotation change
            };
            slider.onchange = function() {
                input.value = slider.value;
            };
            controlsContainer.appendChild(slider);

            // Rotation Input
            const input = document.createElement('input');
            input.type = 'number';
            input.value = initialRotation;
            input.step = 0.01;
            input.oninput = function() {
                const rotation = parseFloat(input.value);
                slider.value = rotation;
                sliderValue.textContent = rotation;
                updateProtractorRotation(id, rotation);
                updateDataPanel(); // Update data panel on rotation change
            };
            controlsContainer.appendChild(input);

            controlsContainer.appendChild(document.createElement('br'));

            // Cursor Slider
            const cursorSlider = document.createElement('input');
            cursorSlider.type = 'range';
            cursorSlider.min = 0;
            cursorSlider.max = 360 / regime.ratio;  // Full rotation in the unit of the regime
            cursorSlider.step = 0.01;
            cursorSlider.value = 0; // Default to 0
            cursorSlider.oninput = function() {
                const cursorPosition = parseFloat(cursorSlider.value);
                cursorSliderValue.textContent = cursorPosition;
                cursorInput.value = cursorPosition;
                updateProtractorCursor(id, cursorPosition);
                updateDataPanel(); // Update data panel on cursor position change
            };
            cursorSlider.onchange = function() {
                cursorInput.value = cursorSlider.value;
            };
            controlsContainer.appendChild(cursorSlider);

            const cursorSliderValue = document.createElement('span');
            cursorSliderValue.className = 'slider-value';
            cursorSliderValue.textContent = 0; // Default to 0
            controlsContainer.appendChild(cursorSliderValue);

            // Cursor Input
            const cursorInput = document.createElement('input');
            cursorInput.type = 'number';
            cursorInput.value = 0; // Default to 0
            cursorInput.step = 0.01;
            cursorInput.oninput = function() {
                const cursorPosition = parseFloat(cursorInput.value);
                cursorSlider.value = cursorPosition;
                cursorSliderValue.textContent = cursorPosition;
                updateProtractorCursor(id, cursorPosition);
                updateDataPanel(); // Update data panel on cursor position change
            };
            controlsContainer.appendChild(cursorInput);

            controlsContainer.appendChild(document.createElement('br'));

            // Append to main controls container
            document.getElementById('controls').appendChild(controlsContainer);

            return controlsContainer;
        }

        function updateProtractorRotation(id, rotation) {
            const protractor = protractors.find(p => p.id === id);
            if (protractor) {
                protractor.rotation = rotation;
                const rotationCanvas = regimeToCanvas(rotation, protractor.regime) + protractor.regime.offset;
                protractor.group.setAttribute('transform', `translate(${protractor.cx}, ${protractor.cy}) scale(${protractor.scale}) rotate(${rotationCanvas})`);
            }
        }

        function updateProtractorCursor(id, cursorPosition) {
            const protractor = protractors.find(p => p.id === id);
            if (protractor) {
                protractor.cursorPosition = cursorPosition;
                positionCursor(protractor.cursor, cursorPosition, protractor.regime, protractor.scale);
            }
        }

        function updateProtractorRegime(id, newRegimeName) {
            const protractor = protractors.find(p => p.id === id);
            if (protractor) {
                const oldRegime = protractor.regime;
                const newRegime = regimes[newRegimeName];

                // Convert cursor position and rotation from old regime to new regime
                const newCursorPosition = convertCursorValue(protractor.cursorPosition, oldRegime, newRegime);
                const newRotation = convertRotationValue(protractor.rotation, oldRegime, newRegime);

                // Update the regime for the specified protractor
                protractor.regime = newRegime;
                protractor.cursorPosition = newCursorPosition;
                protractor.rotation = newRotation;

                // Redraw protractor with new regime
                protractorsContainer.removeChild(protractor.group);
                protractor.group = createProtractorGroup(protractor.cx, protractor.cy, protractor.scale, newRotation, newRegimeName);
                protractorsContainer.appendChild(protractor.group);

                // Redraw cursor
                positionCursor(protractor.cursor, protractor.cursorPosition, protractor.regime, protractor.scale);
                protractor.group.appendChild(protractor.cursor);
            }

            // Redraw all controls
            while (controlsContainer.firstChild) {
                controlsContainer.removeChild(controlsContainer.firstChild);
            }
            protractors.forEach(p => {
                createControls(p.id, p.rotation, p.regime.name, p.scale);
            });

            // Update data panel on regime change
            updateDataPanel();
        }

        function calculateAngleDifference(angle1, angle2) {
            let diff = angle1 - angle2;
            while (diff > 180) diff -= 360;
            while (diff < -180) diff += 360;
            return diff;
        }

        function updateDataPanel() {
            const dataPanel = document.getElementById('data-panel');
            dataPanel.innerHTML = '';

            if (protractors.length < 2) {
                dataPanel.textContent = 'Not enough protractors to calculate relative angles.';
                return;
            }

            const p1 = protractors[0];
            const p2 = protractors[1];

            // Calculate relative angles
            const p1RotationCanvas = regimeToCanvas(p1.rotation, p1.regime) + p1.regime.offset;
            const p2RotationCanvas = regimeToCanvas(p2.rotation, p2.regime) + p2.regime.offset;

            const p1CursorCanvas = regimeToCanvas(p1.cursorPosition, p1.regime);
            const p2CursorCanvas = regimeToCanvas(p2.cursorPosition, p2.regime);

            const p1RelativeToP2Canvas = calculateAngleDifference(p1RotationCanvas, p2RotationCanvas);
            const p2RelativeToP1Canvas = calculateAngleDifference(p2RotationCanvas, p1RotationCanvas);

            const p1RelativeToP2InP1Units = p1.regime.labelFunction(p1RelativeToP2Canvas / p1.regime.ratio);
            const p1RelativeToP2InP2Units = p2.regime.labelFunction(p1RelativeToP2Canvas / p2.regime.ratio);

            const p2RelativeToP1InP2Units = p2.regime.labelFunction(p2RelativeToP1Canvas / p2.regime.ratio);
            const p2RelativeToP1InP1Units = p1.regime.labelFunction(p2RelativeToP1Canvas / p1.regime.ratio);

            const p1CursorRelativeToP2Canvas = calculateAngleDifference(p1RotationCanvas + p1CursorCanvas, p2RotationCanvas);
            const p2CursorRelativeToP1Canvas = calculateAngleDifference(p2RotationCanvas + p2CursorCanvas, p1RotationCanvas);

            const p1CursorRelativeToP2InP1Units = p1.regime.labelFunction(p1CursorRelativeToP2Canvas / p1.regime.ratio);
            const p1CursorRelativeToP2InP2Units = p2.regime.labelFunction(p1CursorRelativeToP2Canvas / p2.regime.ratio);

            const p2CursorRelativeToP1InP2Units = p2.regime.labelFunction(p2CursorRelativeToP1Canvas / p2.regime.ratio);
            const p2CursorRelativeToP1InP1Units = p1.regime.labelFunction(p2CursorRelativeToP1Canvas / p1.regime.ratio);

            const cursorToCursorCanvas = calculateAngleDifference(p1RotationCanvas + p1CursorCanvas, p2RotationCanvas + p2CursorCanvas);

            const cursorToCursorInP1Units = p1.regime.labelFunction(cursorToCursorCanvas / p1.regime.ratio);
            const cursorToCursorInP2Units = p2.regime.labelFunction(cursorToCursorCanvas / p2.regime.ratio);

            const cursorToCursorInP1UnitsReverse = p1.regime.labelFunction(-cursorToCursorCanvas / p1.regime.ratio);
            const cursorToCursorInP2UnitsReverse = p2.regime.labelFunction(-cursorToCursorCanvas / p2.regime.ratio);

            // Display results
            dataPanel.innerHTML = `
                <p>Relative Angles:</p>
                <ul>
                    <li>P1=>P2: ${p1RelativeToP2InP1Units}, ${p1RelativeToP2InP2Units}</li>
                    <li>P2=>P1: ${p2RelativeToP1InP2Units}, ${p2RelativeToP1InP1Units}</li>
                    <li>C1=>P2: ${p1CursorRelativeToP2InP1Units}, ${p1CursorRelativeToP2InP2Units}</li>
                    <li>C2=>P1: ${p2CursorRelativeToP1InP2Units}, ${p2CursorRelativeToP1InP1Units}</li>
                    <li>C1=>C2: ${cursorToCursorInP1Units}, ${cursorToCursorInP2Units}</li>
                    <li>C2=>C1: ${cursorToCursorInP2UnitsReverse}, ${cursorToCursorInP1UnitsReverse}</li>
                </ul>
            `;
        }

        function initializeProtractors() {
            createProtractor(1, 400, 400, 1, 0, 'trig-degrees');
            createProtractor(2, 400, 400, 0.75, 45, 'html5');  // Example of overlapping protractors with different scales and regimes
        }

        initializeProtractors();
    </script>
</body>
</html>
