<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TryAngle - Relative Angle Explorer</title>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
        }
        .degree-label {
            font-size: 20px; /* Tripled font size */
            text-anchor: middle;
        }
        .tic-mark {
            stroke: black;
        }
        .cursor {
            fill: red;
            stroke: red;
            cursor: pointer;
        }
        .center-cross {
            stroke: black;
        }
        .slider-container {
            margin-top: 20px;
        }
        .slider-label {
            display: block;
            width: 100%;
            margin-bottom: 5px;
        }
        .slider {
            width: 200px;
        }
        .input-container {
            display: flex;
            align-items: center;
        }
        .input-angle {
            width:  75px;
        }
        .input-container input[type="number"] {
            width: 80px; /* Adjusted to fit 10 characters */
            margin-left: 10px;
        }
        #main-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }
        #controls {
            flex: 1 1 200px;
            padding: 10px;
        }
        #data-panel {
            flex: 1 1 auto;
            padding: 10px;
        }
        #protractors {
            flex: 3 1 600px;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="controls">
            <!-- Controls will be generated by JavaScript -->
        </div>
        <div id="data-panel">
            <!-- Data panel will be generated by JavaScript -->
        </div>
        <svg id="protractors" width="100%" height="100%" viewBox="0 0 800 800" preserveAspectRatio="xMidYMid meet">
            <!-- Protractors will be generated by JavaScript -->
        </svg>
    </div>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const protractorsContainer = document.getElementById('protractors');
        const controlsContainer = document.getElementById('controls');
        const dataPanelContainer = document.getElementById('data-panel');

        const BASE_RADIUS = 380;
        const TAU = 2 * Math.PI;

        let protractors = [];
        let draggingProtractor = null;
        let draggingCursor = null;

        const regimes = {
            "html5": { name: "html5", unit: "degrees", direction: 1, ratio: 1, offset: 0, minor: 1, major: 10, labelFunction: value => `${toFixedWithoutZeros(value, 3)}째` },
            "trig-degrees": { name: "trig-degrees", unit: "degrees", direction: -1, ratio: 1, offset: 0, minor: 1, major: 10, labelFunction: value => `${toFixedWithoutZeros(value, 3)}째` },
            "trig-radians": { name: "trig-radians", unit: "radians", direction: -1, ratio: 360 / TAU, offset: 0, minor: TAU / 64, major: TAU / 8, labelFunction: value => `${toFixedWithoutZeros(value, 3)}r` },
            "12-hour-clock": { name: "12-hour-clock", unit: "hours", direction: 1, ratio: 30, offset: -90, minor: 0.5, major: 1, labelFunction: value => `${(value % 12 === 0 ? 12 : (value % 12))}` },
            "24-hour-clock": { name: "24-hour-clock", unit: "hours", direction: 1, ratio: 15, offset: -90, minor: 0.5, major: 1, labelFunction: value => `${(value % 24 === 0 ? 24 : (value % 24))}` },
            "nav-marine": { name: "nav-marine", unit: "degrees", direction: 1, ratio: 1, offset: -90, minor: 1, major: 10, labelFunction: value => `${toFixedWithoutZeros(value, 3)}째` },
            "declination": {
                name: "declination", unit: "dms", direction: 1, ratio: 1, offset: -90, minor: 5, major: 2, labelFunction: value => {
                    const isNegative = value < 0;
                    const absValue = Math.abs(value);
                    const degrees = Math.floor(absValue);
                    const minutes = Math.floor((absValue - degrees) * 60);
                    const seconds = Math.floor(((absValue - degrees) * 60 - minutes) * 60);
                    const sign = isNegative ? '-' : '';
                    return `${sign}${degrees}째 ${minutes}' ${seconds}"`
                }
            },
            "right ascention": {
                name: "right ascention", unit: "hms", direction: 1, ratio: 15, offset: -90, minor: 0.5, major: 1, labelFunction: value => {
                    const isNegative = value < 0;
                    const absValue = Math.abs(value);
                    const hours = Math.floor(absValue);
                    const minutes = Math.floor((absValue - hours) * 60);
                    const seconds = Math.floor(((absValue - hours) * 60 - minutes) * 60);
                    const sign = isNegative ? '-' : '';
                    return `${sign}${hours}h ${minutes}' ${seconds}"`
                }
            }
        };

        const toFixedWithoutZeros = (num, precision) =>`${Number.parseFloat(num.toFixed(precision))}`;

        function regimeToCanvas(angle_regime, regime) {
            return angle_regime * regime.direction * regime.ratio;
        }

        function convertCursorValue(oldValue, oldRegime, newRegime) {
            const oldValueInDegrees = oldValue * oldRegime.ratio;
            return oldValueInDegrees / newRegime.ratio;
        }

        function convertRotationValue(oldRotation, oldRegime, newRegime) {
            const oldRotationInDegrees = oldRotation * oldRegime.ratio;
            return oldRotationInDegrees / newRegime.ratio;
        }

        function createProtractor(id, cx, cy, scale, rotation, regimeName) {
            const protractorGroup = createProtractorGroup(cx, cy, scale, rotation, regimeName);

            protractors.push({
                id: id,
                cx: cx,
                cy: cy,
                scale: scale,
                rotation: rotation,
                cursorPosition: 0, // Default cursor position
                regime: regimes[regimeName],
                group: protractorGroup,
                cursor: null, // Placeholder for cursor
                element: createControls(id, rotation, regimeName, scale)
            });

            // Append the protractor group to the container
            protractorsContainer.appendChild(protractorGroup);

            // Cursor (drawn last)
            const cursor = document.createElementNS(svgNS, 'circle');
            cursor.setAttribute('class', 'cursor');
            cursor.setAttribute('r', 20); // Larger circle for handle
            cursor.setAttribute('cx', 0); // Red dot center
            cursor.setAttribute('cy', 0); // Red dot center
            cursor.style.fill = "rgba(255,0,0,0.3)"; // Transparent red for handle
            const cursorDot = document.createElementNS(svgNS, 'circle');
            cursorDot.setAttribute('r', 10); // Red dot radius
            cursorDot.style.fill = "red";
            cursor.appendChild(cursorDot);
            positionCursor(cursor, 0, regimes[regimeName], scale); // Position cursor correctly

            protractors[protractors.length - 1].cursor = cursor;
            protractorGroup.appendChild(cursor);

            // Add event listeners for dragging
            addDragListeners(protractorGroup, cursor, id);

            // Update the data panel initially
            updateDataPanel();
        }

        function createProtractorGroup(cx, cy, scale, rotation, regimeName) {
            const regime = regimes[regimeName];
            const protractorGroup = document.createElementNS(svgNS, 'g');
            protractorGroup.setAttribute('transform', `translate(${cx}, ${cy}) scale(${scale}) rotate(${regimeToCanvas(rotation, regime) + regime.offset})`);

            // Circle
            const circle = document.createElementNS(svgNS, 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', BASE_RADIUS);
            circle.setAttribute('stroke', 'black');
            circle.setAttribute('fill', 'none');
            protractorGroup.appendChild(circle);

            // Center cross
            const centerCross1 = document.createElementNS(svgNS, 'line');
            centerCross1.setAttribute('x1', -5);
            centerCross1.setAttribute('y1', 0);
            centerCross1.setAttribute('x2', 5);
            centerCross1.setAttribute('y2', 0);
            centerCross1.setAttribute('class', 'center-cross');
            protractorGroup.appendChild(centerCross1);

            const centerCross2 = document.createElementNS(svgNS, 'line');
            centerCross2.setAttribute('x1', 0);
            centerCross2.setAttribute('y1', -5);
            centerCross2.setAttribute('x2', 0);
            centerCross2.setAttribute('y2', 5);
            centerCross2.setAttribute('class', 'center-cross');
            protractorGroup.appendChild(centerCross2);

            // Tic marks and labels
            const minorTickLength = 10;
            const majorTickLength = 20;

            const totalTicks = 360 / regime.minor / regime.ratio; // Total ticks for the regime

            for (let i = 0; i < totalTicks; i++) {
                const value_regime = i * regime.minor;
                const angle_canvas_degrees = regimeToCanvas(value_regime, regime);
                const angle_canvas_radians = angle_canvas_degrees * (Math.PI / 180); // Convert to radians for trig functions

                const x1 = BASE_RADIUS * Math.cos(angle_canvas_radians);
                const y1 = BASE_RADIUS * Math.sin(angle_canvas_radians);
                const length = (value_regime % regime.major === 0) ? majorTickLength : minorTickLength;
                const x2 = (BASE_RADIUS - length) * Math.cos(angle_canvas_radians);
                const y2 = (BASE_RADIUS - length) * Math.sin(angle_canvas_radians);

                const ticMark = document.createElementNS(svgNS, 'line');
                ticMark.setAttribute('x1', x1);
                ticMark.setAttribute('y1', y1);
                ticMark.setAttribute('x2', x2);
                ticMark.setAttribute('y2', y2);
                ticMark.setAttribute('class', 'tic-mark');
                protractorGroup.appendChild(ticMark);

                if (value_regime % regime.major === 0) {
                    const labelX = (BASE_RADIUS - majorTickLength - 10) * Math.cos(angle_canvas_radians);
                    const labelY = (BASE_RADIUS - majorTickLength - 10) * Math.sin(angle_canvas_radians);
                    const label = document.createElementNS(svgNS, 'text');
                    label.setAttribute('x', labelX);
                    label.setAttribute('y', labelY);
                    label.setAttribute('class', 'degree-label');
                    label.setAttribute('transform', `rotate(${angle_canvas_degrees}, ${labelX}, ${labelY})`);
                    label.textContent = regime.labelFunction(value_regime);
                    protractorGroup.appendChild(label);
                }
            }

            return protractorGroup;
        }

        function positionCursor(cursor, cursorPosition, regime, scale) {
            const angle_canvas = regimeToCanvas(cursorPosition, regime);
            const angle_canvas_radians = angle_canvas * (Math.PI / 180); // Convert to radians for trig functions
            const x = BASE_RADIUS * Math.cos(angle_canvas_radians);
            const y = BASE_RADIUS * Math.sin(angle_canvas_radians);
            cursor.setAttribute('transform', `translate(${x}, ${y}) scale(${scale})`);
        }

        function addDragListeners(protractorGroup, cursor, id) {
            let isDraggingProtractor = false;
            let isDraggingCursor = false;
            let startAngleProtractor = 0;
            let startAngleCursor = 0;

            const onMouseDown = (event) => {
                event.preventDefault();
                const target = event.target;

                if (target.closest('.cursor')) {
                    isDraggingCursor = true;
                    startAngleCursor = getMouseAngle(event, protractorGroup);
                } else {
                    isDraggingProtractor = true;
                    startAngleProtractor = getMouseAngle(event, protractorGroup);
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };

            const onMouseMove = (event) => {
                const protractor = protractors.find(p => p.id === id);
                if (!protractor) return;

                if (isDraggingProtractor) {
                    const angle = getMouseAngle(event, protractorGroup);
                    const delta = (angle - startAngleProtractor) * regimes[protractor.regime.name].direction;
                    startAngleProtractor = angle;

                    protractor.rotation += delta / protractor.regime.ratio;
                    updateProtractorRotation(id, protractor.rotation);
                    updateControls(id, 'rotation', protractor.rotation);
                    updateDataPanel();
                } else if (isDraggingCursor) {
                    const angle = getMouseAngle(event, protractorGroup);
                    const delta = (angle - startAngleCursor) * regimes[protractor.regime.name].direction;
                    startAngleCursor = angle;

                    protractor.cursorPosition += delta / protractor.regime.ratio;
                    if (protractor.cursorPosition < 0) {
                        protractor.cursorPosition += 360 / protractor.regime.ratio;
                    } else if (protractor.cursorPosition >= 360 / protractor.regime.ratio) {
                        protractor.cursorPosition -= 360 / protractor.regime.ratio;
                    }
                    updateProtractorCursor(id, protractor.cursorPosition);
                    updateControls(id, 'cursor', protractor.cursorPosition);
                    updateDataPanel();
                }
            };

            const onMouseUp = () => {
                isDraggingProtractor = false;
                isDraggingCursor = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            protractorGroup.addEventListener('mousedown', onMouseDown);
            cursor.addEventListener('mousedown', onMouseDown);
        }

        function getMouseAngle(event, element) {
            const rect = protractorsContainer.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const x = event.clientX - cx;
            const y = event.clientY - cy;
            return Math.atan2(y, x) * (180 / Math.PI);
        }

        function createControls(id, initialRotation, regimeName, scale) {
            const regime = regimes[regimeName];
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'slider-container';
            controlsContainer.setAttribute('id', `controls-${id}`);

            // Regime Selector
            const regimeLabel = document.createElement('label');
            regimeLabel.textContent = `Protractor ${id} Regime: `;
            controlsContainer.appendChild(regimeLabel);

            const regimeSelect = document.createElement('select');
            regimeSelect.onchange = function() {
                const newRegimeName = regimeSelect.value;
                updateProtractorRegime(id, newRegimeName);
            };
            for (let key in regimes) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = regimes[key].name;
                if (key === regimeName) {
                    option.selected = true;
                }
                regimeSelect.appendChild(option);
            }
            controlsContainer.appendChild(regimeSelect);

            // Rotation Slider
            const rotationContainer = document.createElement('div');
            rotationContainer.setAttribute('id', `rotation-controls-${id}`);

            const sliderLabel = document.createElement('span');
            sliderLabel.className = 'slider-label';
            sliderLabel.textContent = `Rotation (${regime.unit}): `;
            rotationContainer.appendChild(sliderLabel);

            const slider = document.createElement('input');
            slider.className = 'slider'
            slider.type = 'range';
            slider.min = -3 * 360 / regime.ratio;  // Allow for 3 full rotations in either direction
            slider.max = 3 * 360 / regime.ratio;
            slider.value = initialRotation;
            slider.oninput = function() {
                const rotation = parseFloat(slider.value);
                input.value = rotation.toFixed(3);
                updateProtractorRotation(id, rotation);
                updateDataPanel(); // Update data panel on rotation change
            };
            slider.onchange = function() {
                input.value = parseFloat(slider.value).toFixed(3);
            };
            rotationContainer.appendChild(slider);

            // Rotation Input
            const input = document.createElement('input');
            input.type = 'number';
            input.className =  'input-angle'
            input.value = parseFloat(initialRotation).toFixed(3);
            input.step = 0.01;
            input.oninput = function() {
                const rotation = parseFloat(input.value);
                slider.value = rotation;
                updateProtractorRotation(id, rotation);
                updateDataPanel(); // Update data panel on rotation change
            };
            rotationContainer.appendChild(input);

            controlsContainer.appendChild(rotationContainer);

            // Cursor Slider
            const cursorContainer = document.createElement('div');
            cursorContainer.setAttribute('id', `cursor-controls-${id}`);

            const cursorLabel = document.createElement('span');
            cursorLabel.className = 'slider-label';
            cursorLabel.textContent = `Cursor (${regime.unit}): `;
            cursorContainer.appendChild(cursorLabel);

            const cursorSlider = document.createElement('input');
            cursorSlider.type = 'range';
            cursorSlider.className =  'slider';
            cursorSlider.min = 0;
            cursorSlider.max = 360 / regime.ratio;  // Full rotation in the unit of the regime
            cursorSlider.step = 0.01;
            cursorSlider.value = 0; // Default to 0
            cursorSlider.oninput = function() {
                const cursorPosition = parseFloat(cursorSlider.value);
                cursorInput.value = cursorPosition.toFixed(3);
                updateProtractorCursor(id, cursorPosition);
                updateDataPanel(); // Update data panel on cursor position change
            };
            cursorSlider.onchange = function() {
                cursorInput.value = parseFloat(cursorSlider.value).toFixed(3);
            };
            cursorContainer.appendChild(cursorSlider);

            // Cursor Input
            const cursorInput = document.createElement('input');
            cursorInput.type = 'number';
            cursorInput.className =  'input-angle'
            cursorInput.value = 0; // Default to 0
            cursorInput.step = 0.01;
            cursorInput.oninput = function() {
                const cursorPosition = parseFloat(cursorInput.value);
                cursorSlider.value = cursorPosition;
                updateProtractorCursor(id, cursorPosition);
                updateDataPanel(); // Update data panel on cursor position change
            };
            cursorContainer.appendChild(cursorInput);

            controlsContainer.appendChild(cursorContainer);

            controlsContainer.appendChild(document.createElement('br'));

            // Append to main controls container
            document.getElementById('controls').appendChild(controlsContainer);

            return controlsContainer;
        }

        function updateControls(id, type, value) {
            const controlsContainer = document.getElementById(`controls-${id}`);
            if (controlsContainer) {
                const controlId = type === 'rotation' ? `rotation-controls-${id}` : `cursor-controls-${id}`;
                const controlContainer = document.getElementById(controlId);
                const slider = controlContainer.querySelector(`input[type="range"]`);
                const input = controlContainer.querySelector(`input[type="number"]`);

                if (slider && input) {
                    slider.value = value;
                    input.value = value.toFixed(3);
                }
            }
        }

        function updateProtractorRotation(id, rotation) {
            const protractor = protractors.find(p => p.id === id);
            if (protractor) {
                protractor.rotation = rotation;
                const rotationCanvas = regimeToCanvas(rotation, protractor.regime) + protractor.regime.offset;
                protractor.group.setAttribute('transform', `translate(${protractor.cx}, ${protractor.cy}) scale(${protractor.scale}) rotate(${rotationCanvas})`);
            }
        }

        function updateProtractorCursor(id, cursorPosition) {
            const protractor = protractors.find(p => p.id === id);
            if (protractor) {
                protractor.cursorPosition = cursorPosition;
                positionCursor(protractor.cursor, cursorPosition, protractor.regime, protractor.scale);
            }
        }

        function updateProtractorRegime(id, newRegimeName) {
            // Cache the current settings of the protractors
            const cachedProtractors = protractors.map(protractor => ({
                id: protractor.id,
                cx: protractor.cx,
                cy: protractor.cy,
                scale: protractor.scale,
                rotation: protractor.rotation,
                cursorPosition: protractor.cursorPosition,
                regimeName: protractor.regime.name
            }));

            const protractorToUpdate = cachedProtractors.find(p => p.id === id);
            if (protractorToUpdate) {
                protractorToUpdate.regimeName = newRegimeName;

                // Convert cursor position and rotation from old regime to new regime
                const oldRegime = protractors.find(p => p.id === id).regime;
                const newRegime = regimes[newRegimeName];

                protractorToUpdate.cursorPosition = convertCursorValue(protractorToUpdate.cursorPosition, oldRegime, newRegime);
                protractorToUpdate.rotation = convertRotationValue(protractorToUpdate.rotation, oldRegime, newRegime);
            }

            // Remove all protractors and controls
            while (protractorsContainer.firstChild) {
                protractorsContainer.removeChild(protractorsContainer.firstChild);
            }
            protractors = [];

            // Recreate both protractors with updated regime
            cachedProtractors.forEach(protractor => {
                createProtractor(protractor.id, protractor.cx, protractor.cy, protractor.scale, protractor.rotation, protractor.regimeName);
                updateProtractorCursor(protractor.id, protractor.cursorPosition); // Update cursor position
            });

            // Redraw all controls
            while (controlsContainer.firstChild) {
                controlsContainer.removeChild(controlsContainer.firstChild);
            }
            protractors.forEach(p => {
                createControls(p.id, p.rotation, p.regime.name, p.scale);
            });

            // Update data panel on regime change
            updateDataPanel();
        }

        function calculateAngleDifference(angle1, angle2) {
            let diff = angle1 - angle2;
            while (diff > 180) diff -= 360;
            while (diff < -180) diff += 360;
            return diff;
        }

        function updateDataPanel() {
            const dataPanel = document.getElementById('data-panel');
            dataPanel.innerHTML = '';

            if (protractors.length < 2) {
                dataPanel.textContent = 'Not enough protractors to calculate relative angles.';
                return;
            }

            const p1 = protractors[0];
            const p2 = protractors[1];

            // Calculate relative angles (Page normalized relative angles)
            const p1RotationCanvas = regimeToCanvas(p1.rotation, p1.regime) + p1.regime.offset;
            const p2RotationCanvas = regimeToCanvas(p2.rotation, p2.regime) + p2.regime.offset;

            const p1CursorCanvas = regimeToCanvas(p1.cursorPosition, p1.regime);
            const p2CursorCanvas = regimeToCanvas(p2.cursorPosition, p2.regime);

            const p1RelativeToP2Canvas = calculateAngleDifference(p1RotationCanvas, p2RotationCanvas);
            const p2RelativeToP1Canvas = calculateAngleDifference(p2RotationCanvas, p1RotationCanvas);

            const p1RelativeToP2InP1Units = p1.regime.labelFunction(p1RelativeToP2Canvas / p1.regime.ratio);
            const p1RelativeToP2InP2Units = p2.regime.labelFunction(p1RelativeToP2Canvas / p2.regime.ratio);

            const p2RelativeToP1InP2Units = p2.regime.labelFunction(p2RelativeToP1Canvas / p2.regime.ratio);
            const p2RelativeToP1InP1Units = p1.regime.labelFunction(p2RelativeToP1Canvas / p1.regime.ratio);

            const p1CursorRelativeToP2Canvas = calculateAngleDifference(p1RotationCanvas + p1CursorCanvas, p2RotationCanvas);
            const p2CursorRelativeToP1Canvas = calculateAngleDifference(p2RotationCanvas + p2CursorCanvas, p1RotationCanvas);

            const p1CursorRelativeToP2InP1Units = p1.regime.labelFunction(p1CursorRelativeToP2Canvas / p1.regime.ratio);
            const p1CursorRelativeToP2InP2Units = p2.regime.labelFunction(p1CursorRelativeToP2Canvas / p2.regime.ratio);

            const p2CursorRelativeToP1InP2Units = p2.regime.labelFunction(p2CursorRelativeToP1Canvas / p2.regime.ratio);
            const p2CursorRelativeToP1InP1Units = p1.regime.labelFunction(p2CursorRelativeToP1Canvas / p1.regime.ratio);

            const cursorToCursorCanvasP1toP2 = calculateAngleDifference(p1RotationCanvas + p1CursorCanvas, p2RotationCanvas + p2CursorCanvas);
            const cursorToCursorCanvasP2toP1 = calculateAngleDifference(p2RotationCanvas + p2CursorCanvas, p1RotationCanvas + p1CursorCanvas);

            const cursorToCursorInP1Units = p1.regime.labelFunction(cursorToCursorCanvasP1toP2 / p1.regime.ratio);
            const cursorToCursorInP2Units = p2.regime.labelFunction(cursorToCursorCanvasP1toP2 / p2.regime.ratio);
            const cursorToCursorInP1UnitsOpposite = p1.regime.labelFunction(cursorToCursorCanvasP2toP1 / p1.regime.ratio);
            const cursorToCursorInP2UnitsOpposite = p2.regime.labelFunction(cursorToCursorCanvasP2toP1 / p2.regime.ratio);

            // Display Page normalized relative angles
            dataPanel.innerHTML = `
                <p>Page Normalized Relative Angles:</p>
                <ul>
                    <li>P1=>P2: ${p1RelativeToP2InP1Units}, ${p1RelativeToP2InP2Units}</li>
                    <li>P2=>P1: ${p2RelativeToP1InP2Units}, ${p2RelativeToP1InP1Units}</li>
                    <li>C1=>P2: ${p1CursorRelativeToP2InP1Units}, ${p1CursorRelativeToP2InP2Units}</li>
                    <li>C2=>P1: ${p2CursorRelativeToP1InP2Units}, ${p2CursorRelativeToP1InP1Units}</li>
                    <li>C1=>C2: ${cursorToCursorInP1Units}, ${cursorToCursorInP2Units}</li>
                    <li>C2=>C1: ${cursorToCursorInP2UnitsOpposite}, ${cursorToCursorInP1UnitsOpposite}</li>
                </ul>
            `;

            // Calculate Direct relative angles (Direct relative angles)
            const p1RotationDirect = p1.rotation * p1.regime.ratio;
            const p2RotationDirect = p2.rotation * p2.regime.ratio;

            const p1CursorDirect = p1.cursorPosition * p1.regime.ratio;
            const p2CursorDirect = p2.cursorPosition * p2.regime.ratio;

            const p1RelativeToP2Direct = p1RotationDirect - p2RotationDirect;
            const p2RelativeToP1Direct = p2RotationDirect - p1RotationDirect;

            const p1RelativeToP2DirectInP1Units = p1.regime.labelFunction(p1RelativeToP2Direct / p1.regime.ratio);
            const p1RelativeToP2DirectInP2Units = p2.regime.labelFunction(p1RelativeToP2Direct / p2.regime.ratio);

            const p2RelativeToP1DirectInP2Units = p2.regime.labelFunction(p2RelativeToP1Direct / p2.regime.ratio);
            const p2RelativeToP1DirectInP1Units = p1.regime.labelFunction(p2RelativeToP1Direct / p1.regime.ratio);

            const p1CursorRelativeToP2Direct = (p1RotationDirect + p1CursorDirect) - p2RotationDirect;
            const p2CursorRelativeToP1Direct = (p2RotationDirect + p2CursorDirect) - p1RotationDirect;

            const p1CursorRelativeToP2DirectInP1Units = p1.regime.labelFunction(p1CursorRelativeToP2Direct / p1.regime.ratio);
            const p1CursorRelativeToP2DirectInP2Units = p2.regime.labelFunction(p1CursorRelativeToP2Direct / p2.regime.ratio);

            const p2CursorRelativeToP1DirectInP2Units = p2.regime.labelFunction(p2CursorRelativeToP1Direct / p2.regime.ratio);
            const p2CursorRelativeToP1DirectInP1Units = p1.regime.labelFunction(p2CursorRelativeToP1Direct / p1.regime.ratio);

            const cursorToCursorDirectP1toP2 = (p1RotationDirect + p1CursorDirect) - (p2RotationDirect + p2CursorDirect);
            const cursorToCursorDirectP2toP1 = (p2RotationDirect + p2CursorDirect) - (p1RotationDirect + p1CursorDirect);

            const cursorToCursorDirectInP1Units = p1.regime.labelFunction(cursorToCursorDirectP1toP2 / p1.regime.ratio);
            const cursorToCursorDirectInP2Units = p2.regime.labelFunction(cursorToCursorDirectP1toP2 / p2.regime.ratio);
            const cursorToCursorDirectInP1UnitsOpposite = p1.regime.labelFunction(cursorToCursorDirectP2toP1 / p1.regime.ratio);
            const cursorToCursorDirectInP2UnitsOpposite = p2.regime.labelFunction(cursorToCursorDirectP2toP1 / p2.regime.ratio);

            // Display Direct relative angles
            dataPanel.innerHTML += `
                <p>Direct Relative Angles:</p>
                <ul>
                    <li>P1=>P2: ${p1RelativeToP2DirectInP1Units}, ${p1RelativeToP2DirectInP2Units}</li>
                    <li>P2=>P1: ${p2RelativeToP1DirectInP2Units}, ${p2RelativeToP1DirectInP1Units}</li>
                    <li>C1=>P2: ${p1CursorRelativeToP2DirectInP1Units}, ${p1CursorRelativeToP2DirectInP2Units}</li>
                    <li>C2=>P1: ${p2CursorRelativeToP1DirectInP2Units}, ${p2CursorRelativeToP1DirectInP1Units}</li>
                    <li>C1=>C2: ${cursorToCursorDirectInP1Units}, ${cursorToCursorDirectInP2Units}</li>
                    <li>C2=>C1: ${cursorToCursorDirectInP2UnitsOpposite}, ${cursorToCursorDirectInP1UnitsOpposite}</li>
                </ul>
            `;
        }

        function initializeProtractors() {
            createProtractor(1, 400, 400, 1, 0, 'trig-degrees');
            createProtractor(2, 400, 400, 0.75, 45, 'html5');  // Example of overlapping protractors with different scales and regimes
        }

        initializeProtractors();
    </script>
</body>
</html>
